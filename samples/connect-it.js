!function(){const e=e=>e.querySelector('svg > g.gmain'),t=e=>e.querySelector('svg > g.gshadow'),r=(e,t)=>{const r=s(t.parentElement.childNodes,t);return e.querySelector(`.gmain path:nth-child(${r+1})`)},s=(e,t)=>Array.prototype.indexOf.call(e,t),o=e=>{e.style['stroke-dasharray']=5.5},n=e=>{e.style['stroke-dasharray']=0},a=(e,t)=>{let r;for(const[s,o]of Object.entries(t))if(!r){const t=i(e,o);t&&(r=t)}return r},i=(e,t)=>{var r=((t.x2-t.x1)*(e.y1-t.y1)-(t.y2-t.y1)*(e.x1-t.x1))/((t.y2-t.y1)*(e.x2-e.x1)-(t.x2-t.x1)*(e.y2-e.y1)),s=((e.x2-e.x1)*(e.y1-t.y1)-(e.y2-e.y1)*(e.x1-t.x1))/((t.y2-t.y1)*(e.x2-e.x1)-(t.x2-t.x1)*(e.y2-e.y1));return r>=0&&r<=1&&s>=0&&s<=1?{x:e.x1+r*(e.x2-e.x1),y:e.y1+r*(e.y2-e.y1)}:null},d=(e,t)=>({x1:e.x,y1:e.y,x2:t.x,y2:t.y});var f=(e,t)=>{const r=d(e.center,t.center),s=a(r,e.tagLines),o=a(r,t.tagLines);return d(s,o)},c=e=>{const t={x:(r=e).offsetLeft+r.offsetWidth/2,y:r.offsetTop+r.offsetHeight/2};var r;const s=(e=>{var t=new Object;return t.left={x1:e.offsetLeft,y1:e.offsetTop,x2:e.offsetLeft,y2:e.offsetTop+e.offsetHeight},t.top={x1:e.offsetLeft,y1:e.offsetTop,x2:e.offsetLeft+e.offsetWidth,y2:e.offsetTop},t.bottom={x1:e.offsetLeft,y1:e.offsetTop+e.offsetHeight,x2:e.offsetLeft+e.offsetWidth,y2:e.offsetTop+e.offsetHeight},t.right={x1:e.offsetLeft+e.offsetWidth,y1:e.offsetTop,x2:e.offsetLeft+e.offsetWidth,y2:e.offsetTop+e.offsetHeight},t})(e);return{center:t,tagLines:s}};class l{constructor(e){this.nodes=this.parseNodes(e),this.shapes=this.parseAll(e,'shapes shape');const t=this.parseAll(e,'edges edge');this.setShapeIds(),this.setNodesAdjecentsAndProps(t),this.links=this.getLinks()}setNodesAdjecentsAndProps(e){e.forEach((e=>{const t=this.getById(this.nodes,e.from),r=this.getById(this.nodes,e.to);r&&t&&t.adjacents.push({to:r,...this.getMarkers(e),color:e.color,size:e.size})}))}getLinks(){const e=[];return this.nodes.forEach(((t,r)=>{t.adjacents.forEach((r=>{const s=f(t,r.to);e.push({line:s,markerStart:r.markerStart?.id+'Start',markerEnd:r.markerEnd?.id+'End',color:r.color,size:r.size})}))})),e}parseAll(e,t){return[...e.querySelectorAll(t)].map(this.parseTag)}getById(e,t){return e.filter((e=>e.id==t))[0]}getByName(e,t){return e.filter((e=>e.name==t))[0]}getMarkers(e){return{markerStart:this.getByName(this.shapes,e['marker-start']),markerEnd:this.getByName(this.shapes,e['marker-end'])}}setShapeIds(){this.shapes.forEach((e=>e.id=e.name))}parseNodes(e){const t=[];return e.querySelectorAll('nodes *[id]').forEach(((e,r)=>{const s=c(e);t.push({id:e.attributes.id?.value,...s,adjacents:[]})})),t}parseTag=e=>{const t={name:e.tagName,...this.getAttributes(e)};return e.children.length>0&&(t.children=[...e.children].map(this.parseTag)),t};getAttributes(e){const t=[];return[...e.attributes].map((e=>{t[e.name]=e.value})),t}}const h=(e,t)=>{const r=`M${(s=t.line).x1},${s.y1} L${s.x2},${s.y2} `;var s;e.main.innerHTML+=((e,t)=>`<path d="${e}" \n    stroke="${t.color}" \n    stroke-width="${t.size??2}" \n    marker-start="url(#${t.markerStart})"\n    marker-end="url(#${t.markerEnd})"\n    "/>`)(r,t),e.shadows.innerHTML+=(e=>`<path stroke="transparent" stroke-width="12" d="${e}"/>`)(r)};class m extends HTMLElement{constructor(){super(),this.onLoad((()=>{var s;this.addCommonStyles(),this.vdom=new l(this),(s=this).insertAdjacentHTML('afterbegin','<svg style="position: absolute; top: 0; left: 0; width:100%; height:100%;">\n    <defs></defs><g class="gmain" fill="none" stroke="black" stroke-width="2"></g><g class="gshadow"></g>\n    </svg>'),s.defs=s.querySelector('defs'),(e=>{e.addEventListener('click',(t=>{if(t.target.parentElement.classList.contains('gshadow')){const s=r(e,t.target);o(s),e.setAttribute('selected','')}else(e=>e.querySelectorAll('path'))(e).forEach((e=>{n(e)})),e.removeAttribute('selected')})),e.addEventListener('mouseout',(t=>{if(t.target.parentElement.classList.contains('gshadow')){if(e.hasAttribute('selected'))return;const s=r(e,t.target);n(s)}})),e.addEventListener('mouseover',(t=>{if(t.target.parentElement.classList.contains('gshadow')){const s=r(e,t.target);o(s)}}))})(this),(e=>{e.defs.innerHTML='',e.vdom.shapes.forEach((t=>{let r='';switch(t.type){case'triangle':r=(e=>{const t=e.size??6,r=t/2,s=e.color??'black';return`<marker id="${e.id}Start" orient="auto" refY="${r}" refX="0" \n    markerHeight="${t}" markerWidth="${t}" viewBox="0 0 ${t} ${t}">\n        <polygon points="0,0 0,${t} ${r},${r}" fill="${s}"></polygon>\n  </marker>\n  <marker id="${e.id}End" orient="auto" refY="${r}" refX="${r}" \n    markerHeight="${t}" markerWidth="${t}" viewBox="0 0 ${t} ${t}">\n        <polygon points="0,0 0,${t} ${r},${r}" fill="${s}"></polygon>\n  </marker>`})(t);break;case'circle':r=(e=>{const t=e.size??6,r=t/2,s=e.color??'black';return`<marker id="${e.id}Start" orient="auto" refY="${r}" refX="0" markerHeight="${t}" markerWidth="${t}" viewBox="0 0 ${t} ${t}">\n    <circle cx=${r} cy=${r} r=${r}  fill="${s}"></circle>\n  </marker>\n  <marker id="${e.id}End" orient="auto" refY="${r}" refX="${t}" markerHeight="${t}" markerWidth="${t}" viewBox="0 0 ${t} ${t}">\n      <circle cx=${r} cy=${r} r=${r}  fill="${s}"></circle>\n  </marker>`})(t);break;case'square':r=(e=>{const t=e.size??6,r=t/2,s=e.color??'black';return`<marker id="${e.id}Start" orient="auto" refY="${r/2}" refX="0" markerHeight="${t}" markerWidth="${t}" viewBox="0 0 ${t} ${t}">\n    <rect x="0" y="0" width=${r} height=${r}  fill="${s}"/>\n  </marker>\n  <marker id="${e.id}End" orient="auto" refY="${r/2}" refX="${r}" markerHeight="${t}" markerWidth="${t}" viewBox="0 0 ${t} ${t}">\n    <rect x="0" y="0" width=${r} height=${r}  fill="${s}"/>\n  </marker>`})(t)}e.defs.insertAdjacentHTML('beforeend',r)}))})(this),(r=>{const s=(r=>{const s=e(r),o=t(r);return s.innerHTML='',o.innerHTML='',{main:s,shadows:o}})(r);r.vdom.links.forEach(((e,t)=>{h(s,e)}))})(this)}))}onLoad=e=>{Promise.all(Array.from(this.querySelectorAll('img')).filter((e=>!e.complete)).map((e=>new Promise((t=>{e.onload=e.onerror=t}))))).then((()=>{e()}))};addCommonStyles=()=>{this.style.overflow='hidden',this.style['z-index']='1'}}customElements.define('connect-it',m)}();
//# sourceMappingURL=connect-it.js.map
