!function(){const e=e=>e.querySelector('svg > g.gmain'),t=e=>e.querySelector('svg > g.gshadow'),r=(e,t)=>{let r;for(const[o,n]of Object.entries(t))if(!r){const t=s(e,n);t&&(r=t)}return r},s=(e,t)=>{var r=((t.x2-t.x1)*(e.y1-t.y1)-(t.y2-t.y1)*(e.x1-t.x1))/((t.y2-t.y1)*(e.x2-e.x1)-(t.x2-t.x1)*(e.y2-e.y1)),s=((e.x2-e.x1)*(e.y1-t.y1)-(e.y2-e.y1)*(e.x1-t.x1))/((t.y2-t.y1)*(e.x2-e.x1)-(t.x2-t.x1)*(e.y2-e.y1));return r>=0&&r<=1&&s>=0&&s<=1?{x:e.x1+r*(e.x2-e.x1),y:e.y1+r*(e.y2-e.y1)}:null},o=(e,t)=>({x1:e.x,y1:e.y,x2:t.x,y2:t.y});var n=(e,t)=>{const s=o(e.center,t.center),n=r(s,e.tagLines),i=r(s,t.tagLines);return o(n,i)},i=e=>{const t={x:(r=e).offsetLeft+r.offsetWidth/2,y:r.offsetTop+r.offsetHeight/2};var r;const s=(e=>{var t=new Object;return t.left={x1:e.offsetLeft,y1:e.offsetTop,x2:e.offsetLeft,y2:e.offsetTop+e.offsetHeight},t.top={x1:e.offsetLeft,y1:e.offsetTop,x2:e.offsetLeft+e.offsetWidth,y2:e.offsetTop},t.bottom={x1:e.offsetLeft,y1:e.offsetTop+e.offsetHeight,x2:e.offsetLeft+e.offsetWidth,y2:e.offsetTop+e.offsetHeight},t.right={x1:e.offsetLeft+e.offsetWidth,y1:e.offsetTop,x2:e.offsetLeft+e.offsetWidth,y2:e.offsetTop+e.offsetHeight},t})(e);return{center:t,tagLines:s}};class a{constructor(e){this.nodes=this.parseNodes(e),this.shapes=this.parseAll(e,'shapes shape');const t=this.parseAll(e,'edges edge');this.setShapeIds(),this.setNodesAdjecentsAndProps(t),this.links=this.getLinks()}setNodesAdjecentsAndProps(e){e.forEach((e=>{const t=this.getById(this.nodes,e.from),r=this.getById(this.nodes,e.to);r&&t&&(r.center.x!==t.center.x||r.center.y!==t.center.y)&&t.adjacents.push({to:r,...this.getMarkers(e),color:e.color,size:e.size})}))}getLinks(){const e=[];return this.nodes.forEach(((t,r)=>{t.adjacents.forEach((r=>{const s=n(t,r.to);e.push({line:s,markerStart:r.markerStart?.id+'Start',markerEnd:r.markerEnd?.id+'End',color:r.color,size:r.size})}))})),e}parseAll(e,t){return[...e.querySelectorAll(t)].map(this.parseTag)}getById(e,t){return e.filter((e=>e.id==t))[0]}getByName(e,t){return e.filter((e=>e.name==t))[0]}getMarkers(e){return{markerStart:this.getByName(this.shapes,e['marker-start']),markerEnd:this.getByName(this.shapes,e['marker-end'])}}setShapeIds(){this.shapes.forEach((e=>e.id=e.name))}parseNodes(e){const t=[];return e.querySelectorAll('nodes *[id]').forEach(((e,r)=>{const s=i(e);t.push({id:e.attributes.id?.value,...s,adjacents:[]})})),t}parseTag=e=>{const t={name:e.tagName,...this.getAttributes(e)};return e.children.length>0&&(t.children=[...e.children].map(this.parseTag)),t};getAttributes(e){const t=[];return[...e.attributes].map((e=>{t[e.name]=e.value})),t}}const f=(e,t)=>{const r=`M${(s=t.line).x1},${s.y1} L${s.x2},${s.y2} `;var s;e.main.innerHTML+=((e,t)=>`<path d="${e}" \n    stroke="${t.color}" \n    stroke-width="${t.size??2}" \n    marker-start="url(#${t.markerStart})"\n    marker-end="url(#${t.markerEnd})"\n    "/>`)(r,t),e.shadows.innerHTML+=(e=>`<path stroke="transparent" stroke-width="12" d="${e}"/>`)(r)};class c extends HTMLElement{constructor(){super()}connectedCallback(){const e=this;var t;(t=this).insertAdjacentHTML('afterbegin','<svg style="position: absolute; top: 0; left: 0;  z-index:-1">\n    <defs></defs><g class="gmain" fill="none" stroke="black" stroke-width="2"></g><g class="gshadow"></g>\n    </svg>'),t.defs=t.querySelector('defs'),this.onLoad((()=>{e.refresh()})),this.observe((function(t){(t.target.parent!=this||t.target.closest('nodes'))&&e.refresh()}))}disconnectedCallback(){this.observer.disconnect()}observe=e=>{this.observer=new MutationObserver((t=>{t.forEach(e)})),this.observer.observe(document,{attributes:!0,childList:!0,subtree:!0})};refresh=()=>{const r=new a(this);var s;JSON.stringify(r)!==JSON.stringify(this.vdom)&&(this.vdom=r,(s=this).defs.innerHTML='',s.vdom.shapes.forEach((e=>{let t='';switch(e.type){case'triangle':t=(e=>{const t=e.size??6,r=t/2,s=e.color??'black';return`<marker id="${e.id}Start" orient="auto" refY="${r}" refX="0" \n    markerHeight="${t}" markerWidth="${t}" viewBox="0 0 ${t} ${t}">\n        <polygon points="0,0 0,${t} ${r},${r}" fill="${s}"></polygon>\n  </marker>\n  <marker id="${e.id}End" orient="auto" refY="${r}" refX="${r}" \n    markerHeight="${t}" markerWidth="${t}" viewBox="0 0 ${t} ${t}">\n        <polygon points="0,0 0,${t} ${r},${r}" fill="${s}"></polygon>\n  </marker>`})(e);break;case'circle':t=(e=>{const t=e.size??6,r=t/2,s=e.color??'black';return`<marker id="${e.id}Start" orient="auto" refY="${r}" refX="0" markerHeight="${t}" markerWidth="${t}" viewBox="0 0 ${t} ${t}">\n    <circle cx=${r} cy=${r} r=${r}  fill="${s}"></circle>\n  </marker>\n  <marker id="${e.id}End" orient="auto" refY="${r}" refX="${t}" markerHeight="${t}" markerWidth="${t}" viewBox="0 0 ${t} ${t}">\n      <circle cx=${r} cy=${r} r=${r}  fill="${s}"></circle>\n  </marker>`})(e);break;case'square':t=(e=>{const t=e.size??6,r=t/2,s=e.color??'black';return`<marker id="${e.id}Start" orient="auto" refY="${r/2}" refX="0" markerHeight="${t}" markerWidth="${t}" viewBox="0 0 ${t} ${t}">\n    <rect x="0" y="0" width=${r} height=${r}  fill="${s}"/>\n  </marker>\n  <marker id="${e.id}End" orient="auto" refY="${r/2}" refX="${r}" markerHeight="${t}" markerWidth="${t}" viewBox="0 0 ${t} ${t}">\n    <rect x="0" y="0" width=${r} height=${r}  fill="${s}"/>\n  </marker>`})(e)}s.defs.insertAdjacentHTML('beforeend',t)})),(r=>{const s=(r=>{const s=e(r),o=t(r);return s.innerHTML='',o.innerHTML='',{main:s,shadows:o}})(r);r.vdom.links.forEach(((e,t)=>{f(s,e)}))})(this),this.resizeSVG())};resizeSVG=()=>{var e=this.querySelector('svg'),t=e.getBBox();e.setAttribute('width',t.x+t.width+t.x),e.setAttribute('height',t.y+t.height+t.y)};onLoad=e=>{Promise.all(Array.from(this.querySelectorAll('img')).filter((e=>!e.complete)).map((e=>new Promise((t=>{e.onload=e.onerror=t}))))).then((()=>{e()}))}}customElements.get('connect-it')||customElements.define('connect-it',c)}();
//# sourceMappingURL=connect-it.js.map
